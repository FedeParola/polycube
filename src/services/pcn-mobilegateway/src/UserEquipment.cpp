/**
* mobilegateway API generated from mobilegateway.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


#include "UserEquipment.h"
#include "Mobilegateway.h"


UserEquipment::UserEquipment(Mobilegateway &parent, const UserEquipmentJsonObject &conf)
    : UserEquipmentBase(parent) {
  try {
    parent_.getBaseStation(conf.getTunnelEndpoint());
  } catch (std::out_of_range e) {
    throw std::runtime_error("Unknown Base Station " + conf.getTunnelEndpoint());
  }

  ip_ = conf.getIp();
  tunnel_endpoint_ = conf.getTunnelEndpoint();
  teid_ = conf.getTeid();
  if (conf.rateLimitIsSet()) {
    rate_limit_ = conf.getRateLimit();
  } else {
    rate_limit_ = 0;  // No rate limit
  }

  // Add UE data to the data plane
  this->insertIntoDPRoutingTable();
  this->insertIntoDPUserEquipments();
  this->insertIntoDPRateLimits();
}

// Removes UE data from the data plane
UserEquipment::~UserEquipment() {
  uint32_t nbo_ip = ip_string_to_nbo_uint(ip_);

  // Remove UE from the routing table
  auto routing_table = parent_.get_hash_table<rt_k, rt_v>("routing_table");
  rt_k key = {
      .netmask_len = 32,
      .network = nbo_ip,
  };
  routing_table.remove(key);

  // Remove UE data
  auto user_equipments = parent_.get_hash_table<uint32_t, struct ue_data>("user_equipments");
  user_equipments.remove(nbo_ip);

  // Remove packets rate data
  auto packets_rates = parent_.get_hash_table<uint32_t, struct packets_rate_data>("packets_rates");
  packets_rates.remove(htonl(teid_));
}

std::string UserEquipment::getIp() {
  return ip_;
}

std::string UserEquipment::getTunnelEndpoint() {
  return tunnel_endpoint_;
}

void UserEquipment::setTunnelEndpoint(const std::string &value) {
  if (tunnel_endpoint_ == value) {
    return;
  }

  try {
    parent_.getBaseStation(value);
  } catch (std::out_of_range e) {
    throw std::runtime_error("Unknown Base Station " + value);
  }

  tunnel_endpoint_ = value;

  // Update into DP
  this->insertIntoDPRoutingTable();
  this->insertIntoDPUserEquipments();
}

uint32_t UserEquipment::getTeid() {
  return teid_;
}

void UserEquipment::setTeid(const uint32_t &value) {
  if (teid_ == value) {
    return;
  }

  teid_ = value;

  // Update into DP
  this->insertIntoDPUserEquipments();
  this->insertIntoDPRateLimits();
}

uint32_t UserEquipment::getRateLimit() {
  return rate_limit_;
}

void UserEquipment::setRateLimit(const uint32_t &value) {
  if (rate_limit_ == value) {
    return;
  }

  rate_limit_ = value;

  // Update into DP
  this->insertIntoDPRateLimits();
}

void UserEquipment::insertIntoDPRoutingTable() {
  std::string out_port = parent_.search_interface_from_nexthop(tunnel_endpoint_);
  int out_port_index = parent_.get_port(out_port)->index();

  auto routing_table = parent_.get_hash_table<rt_k, rt_v>("routing_table");

  rt_k key = {
      .netmask_len = 32,
      .network = ip_string_to_nbo_uint(ip_),
  };
  rt_v value = {
      .port = uint32_t(out_port_index),
      .nexthop = ip_string_to_nbo_uint(tunnel_endpoint_),
      .type = TYPE_UE,
  };

  routing_table.set(key, value);
}

void UserEquipment::insertIntoDPUserEquipments() {
  auto user_equipments = parent_.get_hash_table<uint32_t, struct ue_data>("user_equipments");

  struct ue_data value = {
    .tunnel_endpoint = ip_string_to_nbo_uint(tunnel_endpoint_),
    .teid = ntohl(teid_),
  };

  user_equipments.set(ip_string_to_nbo_uint(ip_), value);
}

void UserEquipment::insertIntoDPRateLimits() {
  auto packets_rates = parent_.get_hash_table<uint32_t, struct packets_rate_data>("packets_rates");

  struct packets_rate_data value = {
    .limit = rate_limit_,
    .packets_count = 0,
  };

  packets_rates.set(htonl(teid_), value);
}