/**
* mobilegateway API generated from mobilegateway.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/

#include <bcc/helpers.h>
#include <bcc/proto.h>
#include <uapi/linux/bpf.h>
#include <uapi/linux/filter.h>
#include <uapi/linux/icmp.h>
#include <uapi/linux/if_arp.h>
#include <uapi/linux/if_ether.h>
#include <uapi/linux/if_packet.h>
#include <uapi/linux/in.h>
#include <uapi/linux/ip.h>
#include <uapi/linux/pkt_cls.h>
#include <uapi/linux/udp.h>


#define ROUTING_TABLE_DIM 256
#define ROUTER_PORT_N 32
#define ARP_TABLE_DIM 32
#define MAX_SECONDARY_ADDRESSES 5 // also defined in Ports.h
#define TYPE_NOLOCALINTERFACE 0  // used to compare the 'type' field in the rt_v
#define TYPE_LOCALINTERFACE 1
#define TYPE_UE 2
#define IP_CSUM_OFFSET (sizeof(struct eth_hdr) + offsetof(struct iphdr, check))
#define ICMP_CSUM_OFFSET                           \
  (sizeof(struct eth_hdr) + sizeof(struct iphdr) + \
   offsetof(struct icmphdr, checksum))
#define MAC_MULTICAST_MASK 0x1ULL  // network byte order

enum {
  PORT_DIRECTION_UE,
  PORT_DIRECTION_PDN
};

enum {
  SLOWPATH_ARP_REPLY = 1,
  SLOWPATH_ARP_LOOKUP_MISS,
  SLOWPATH_TTL_EXCEEDED,
  SLOWPATH_PKT_FOR_ROUTER
};
/* Routing Table Key */
struct rt_k {
  u32 netmask_len;
  __be32 network;
};
/* Routing Table Value
the type field is used to know if the destination is one interface of the router
*/
struct rt_v {
  u32 port;
  __be32 nexthop;
  u8 type;
};
/* Router Port, also defined in Ports.h */
struct r_port {
  __be32 ip;
  __be32 netmask;
  __be32 secondary_ip[MAX_SECONDARY_ADDRESSES];
  __be32 secondary_netmask[MAX_SECONDARY_ADDRESSES];
  __be64 mac : 48;
  u8 direction;
};
BPF_F_TABLE("lpm_trie", struct rt_k, struct rt_v, routing_table,
            ROUTING_TABLE_DIM, BPF_F_NO_PREALLOC);
/*
Router Port table provides a way to simulate the physical interface of the
router
The ip address is used to answer to the arp request (TO IMPLEMENT)
The mac address is used as mac_src for the outcoming packet on that interface,
and as mac address contained in the arp reply
*/
BPF_TABLE("hash", u16, struct r_port, router_port, ROUTER_PORT_N);
/*
Arp Table implements a mapping between IP and MAC addresses.
*/
struct arp_entry {
  __be64 mac;
  u32 port;
} __attribute__((packed));
BPF_TABLE("hash", u32, struct arp_entry, arp_table, ARP_TABLE_DIM);

// Table containing data of User Equipments
// KEY: IP of the UE
// VAL:
struct ue_data {
  __be32 tunnel_endpoint;  // IP of the Base Station used to reach the UE
  __be32 teid;
} __attribute__((packed));
BPF_HASH(user_equipments, __be32, struct ue_data);

// Table containing data to limit the packets rate for a certain tunnel
// KEY: tunnel id (teid)
// VAL:
struct packets_rate_data {
  u32 limit;
  u32 packets_count;  // Number of packets forwarded in the current time window
} __attribute__((packed));
BPF_HASH(packets_rates, __be32, struct packets_rate_data);

struct eth_hdr {
  __be64 dst : 48;
  __be64 src : 48;
  __be16 proto;
} __attribute__((packed));

struct arp_hdr {
  __be16 ar_hrd;        /* format of hardware address	*/
  __be16 ar_pro;        /* format of protocol address	*/
  unsigned char ar_hln; /* length of hardware address	*/
  unsigned char ar_pln; /* length of protocol address	*/
  __be16 ar_op;         /* ARP opcode (command)		*/
  __be64 ar_sha : 48;   /* sender hardware address	*/
  __be32 ar_sip;        /* sender IP address		*/
  __be64 ar_tha : 48;   /* target hardware address	*/
  __be32 ar_tip;        /* target IP address		*/
} __attribute__((packed));

struct gtp1_header {	/* According to 3GPP TS 29.060. */
	__u8	flags;  
	__u8	type;
	__be16	length;
	__be32	tid;
} __attribute__ ((packed));

#define GTP_PORT 2152
#define GTP_TYPE_GPDU 255  // User data packet (T-PDU) plus GTP-U header 
#define GTP_FLAGS 0x30     // Version: GTPv1, Protocol Type: GTP, Others: 0

// Pseudo IP header for UDP checksum computation
struct ip_pseudo_hdr {
  __be32	saddr;
	__be32	daddr;
  __u8 zero;
  __u8	protocol;
  __be16 udp_length;
} __attribute__ ((packed));

/*the function checks if the packet is an ICMP ECHO REQUEST and source mac is
* not equal to in_port mac, if it is true sends the
* packet to the slowpath. The slowpath searchs if the destination ip is one of
* ip in the router and generates an echo reply
*/
static inline int send_packet_for_router_to_slowpath(struct CTXTYPE *ctx,
                                                     struct pkt_metadata *md,
                                                     struct eth_hdr *eth,
                                                     struct iphdr *ip) {
  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;
  struct icmphdr *icmp = data + sizeof(*eth) + sizeof(*ip);
  if (data + sizeof(*eth) + sizeof(*ip) + sizeof(*icmp) > data_end)
    return RX_DROP;
  u32 mdata[3];
  mdata[0] = ip->saddr;
  mdata[1] = ip->daddr;
  mdata[2] = ip->protocol;
  return pcn_pkt_controller_with_metadata(ctx, md, SLOWPATH_PKT_FOR_ROUTER,
                                          mdata);
}
static inline int send_icmp_ttl_time_exceeded(struct CTXTYPE *ctx,
                                              struct pkt_metadata *md,
                                              __be32 ip_port) {
  pcn_log(ctx, LOG_DEBUG, "packet DROP (ttl = 0)");
  // Set router port ip address as metadata[0]
  u32 mdata[3];
  // using the principal ip as sender address
  mdata[0] = ip_port;
  // Send packet to slowpath
  return pcn_pkt_controller_with_metadata(ctx, md, SLOWPATH_TTL_EXCEEDED,
                                          mdata);
}
static inline int arp_lookup_miss(struct CTXTYPE *ctx, struct pkt_metadata *md,
                                  __be32 dst_ip, u16 out_port, __be32 ip_port) {
  pcn_log(ctx, LOG_DEBUG, "arp lookup failed. Send to controller");

  // Set metadata and send packet to slowpath
  u32 mdata[3];
  mdata[0] = dst_ip;
  mdata[1] = out_port;
  mdata[2] = ip_port;
  return pcn_pkt_controller_with_metadata(ctx, md, SLOWPATH_ARP_LOOKUP_MISS,
                                          mdata);
}

static inline int send_packet_to_output_interface(
    struct CTXTYPE *ctx, struct pkt_metadata *md, struct eth_hdr *eth,
    struct iphdr *ip, __be32 nexthop, u16 out_port, __be32 ip_port,
    __be64 mac_port) {
  __be32 dst_ip = 0;
  if (nexthop == 0)
    // Next Hop is local, directly lookup in arp table for the destination ip.
    dst_ip = ip->daddr;
  else
    // Next Hop not local, lookup in arp table for the next hop ip address.
    dst_ip = nexthop;
  struct arp_entry *entry = arp_table.lookup(&dst_ip);
  if (!entry)
    return arp_lookup_miss(ctx, md, dst_ip, out_port, ip_port);

  pcn_log(ctx, LOG_TRACE, "in: %d out: %d REDIRECT", md->in_port, out_port);

  eth->dst = entry->mac;
  eth->src = mac_port;

  // Decrement TTL and update checksum
  u16 old_ttl = ip->ttl;
  ip->ttl = ip->ttl - 1;
  u16 new_ttl = ip->ttl;
  pcn_l3_csum_replace(ctx, IP_CSUM_OFFSET, old_ttl, new_ttl, 2);

  return pcn_pkt_redirect(ctx, md, out_port);
}

static inline int search_secondary_address(__be32 *arr, __be32 ip) {
  int i, size = MAX_SECONDARY_ADDRESSES;
  for (i = 0; i < size; i++) {
    if (arr[i] == ip)
      return i; /* found */
  }
  return (-1); /* if it was not found */
}
/*when an arp request is received, the router controls if the target if is one
* of its interfaces,
* if it is true, it sends an arp reply to the ingress port
*/
static inline int send_arp_reply(struct CTXTYPE *ctx, struct pkt_metadata *md,
                                 struct eth_hdr *eth, struct arp_hdr *arp,
                                 struct r_port *in_port) {
  __be32 target_ip = arp->ar_tip;
  __be32 sender = 0;
  if (target_ip == in_port->ip)
    sender = in_port->ip;
  else {
    __be32 *arr = in_port->secondary_ip;
    int pos = search_secondary_address(arr, target_ip);
    if (pos > -1)
      sender = arr[pos];
    else
      return RX_DROP;
  }

  pcn_log(ctx, LOG_DEBUG, "somebody is asking for my address");

  __be64 remotemac = arp->ar_sha;
  __be32 remoteip = arp->ar_sip;
  arp->ar_op = bpf_htons(ARPOP_REPLY);
  arp->ar_tha = remotemac;
  arp->ar_sha = in_port->mac;
  arp->ar_sip = sender;
  arp->ar_tip = remoteip;
  eth->dst = remotemac;
  eth->src = in_port->mac;
  /* register the requesting mac and ip */
  struct arp_entry entry;
  entry.mac = remotemac;
  entry.port = md->in_port;
  arp_table.update(&remoteip, &entry);
  return pcn_pkt_redirect(ctx, md, md->in_port);
}
static inline int notify_arp_reply_to_slowpath(struct CTXTYPE *ctx,
                                               struct pkt_metadata *md,
                                               struct arp_hdr *arp) {
  pcn_log(ctx, LOG_DEBUG, "packet is arp reply");

  __be64 mac_ = arp->ar_sha;
  __be32 ip_ = arp->ar_sip;
  struct arp_entry entry;
  entry.mac = mac_;
  entry.port = md->in_port;
  arp_table.update(&ip_, &entry);
  // notify the slowpath. New arp reply received.
  u32 mdata[3];
  mdata[0] = ip_;
  return pcn_pkt_controller_with_metadata(ctx, md, SLOWPATH_ARP_REPLY, mdata);
}
static inline int is_ether_mcast(__be64 mac_address) {
  return (mac_address & (__be64)MAC_MULTICAST_MASK);
}

// Encapsulates ip packet into a GTP tunnel with given src and dst ip addresses
// and given teid.
// Returns 0 in case of success, -1 otherwise.
static inline int gtp_encap(struct CTXTYPE *ctx, __be32 src, __be32 dst, __be32 teid) {
  u32 len_diff = sizeof(struct iphdr) + sizeof(struct udphdr) + sizeof(struct gtp1_header);

  // Add space for encapsulation to packet buffer
#ifdef POLYCUBE_XDP
  bpf_xdp_adjust_head(ctx, 0 - len_diff);
#else
  bpf_skb_adjust_room(ctx, len_diff, BPF_ADJ_ROOM_MAC, 0);
#endif

  // Packet buffer changed, all pointers need to be recomputed
  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;

  struct eth_hdr *eth = data;
  if (data + sizeof(*eth) > data_end) {
    return -1;
  }

#ifdef POLYCUBE_XDP
  // Move the eth header at the beginning of the buffer
  // (Since src and dst addrs are replaced in forwarding I could just set ethertype)
  if (data + len_diff + sizeof(struct eth_hdr) > data_end) {
    return RX_DROP;
  }
  memmove(eth, data + len_diff, sizeof(*eth));
#endif

  struct iphdr *ip = data + sizeof(*eth);
  if ((void *)ip + sizeof(*ip) > data_end) {
    return -1;
  }

  struct iphdr *inner_ip = (void *)ip + len_diff;
  if ((void *)inner_ip + sizeof(*inner_ip) > data_end) {
    return -1;
  }

  // Add the outer IP header
  ip->version = 4;
  ip->ihl = 5;  // No options
  ip->tos = 0;
  ip->tot_len = htons(ntohs(inner_ip->tot_len) + len_diff);
  ip->id = 0;  // No fragmentation
  ip->frag_off = 0x0040;  // Don't fragment; Fragment offset = 0
  ip->ttl = 64;
  ip->protocol = IPPROTO_UDP;
  ip->check = 0;
  ip->saddr = src;
  ip->daddr = dst;

  // Add the UDP header
  struct udphdr *udp = (void *)ip + sizeof(*ip);
  if ((void *)udp + sizeof(*udp) > data_end) {
    return -1;
  }
  udp->source = 0;  // Consider using a random port
  udp->dest = htons(GTP_PORT);
  udp->len = htons(ntohs(inner_ip->tot_len) + sizeof(*udp) + sizeof(struct gtp1_header));
  udp->check = 0;

  // Add the GTP header
  struct gtp1_header *gtp = (void *)udp + sizeof(*udp);
  if ((void *)gtp + sizeof(*gtp) > data_end) {
    return -1;
  }
  gtp->flags = GTP_FLAGS;  
  gtp->type = GTP_TYPE_GPDU;
  gtp->length = inner_ip->tot_len;
  gtp->tid = teid;  // Replace with TEID

  // Compute l3 checksum
  __wsum l3sum = pcn_csum_diff(0, 0, (__be32 *)ip, sizeof(*ip), 0);

  // Compute l4 checksum
  // struct ip_pseudo_hdr pseudo_hdr = {
  //   .saddr = ip->saddr,
  //   .daddr = ip->daddr,
  //   .zero = 0,
  //   .protocol = IPPROTO_UDP,
  //   .udp_length = udp->len
  // };
  // __wsum l4sum = pcn_csum_diff(0, 0, (__be32 *)&pseudo_hdr, sizeof(pseudo_hdr), 0);
  // u32 udp_len = (data_end - (void *)udp);
  // if ((void *)udp + udp_len > data_end) {
  //   pcn_log(ctx, LOG_INFO, "Drop max");
  //   return -1;
  // }
  // l4sum = pcn_csum_diff(0, 0, (__be32 *)udp, udp_len, l4sum);

  // Update checksums
  pcn_l3_csum_replace(ctx, IP_CSUM_OFFSET, 0, l3sum, 0);
  //pcn_l4_csum_replace(ctx, UDP_CSUM_OFFSET, 0, l4sum, 0);

  return 0;
}

// Decapsulates ip packet from GTP tunnel, sets the teid parameter to the
// tunnel teid.
// Returns 0 in case of success, -1 otherwise.
static inline int gtp_decap(struct CTXTYPE *ctx, struct udphdr *udp, __be32 *teid) {
  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;

  // Retrieve teid
  struct gtp1_header *gtp = (void *)udp + sizeof(*udp);
  if ((void *)gtp + sizeof(*gtp) > data_end) {
    return -1;
  }
  *teid = gtp->tid;

  u32 len_diff = sizeof(struct iphdr) + sizeof(struct udphdr) + sizeof(struct gtp1_header);

  // Resize packet buffer
#ifdef POLYCUBE_XDP
    // Move the eth header at the new beginning of the buffer
    // (Since src and dst addrs are replaced in forwarding I could just set ethertype)
    if (data + len_diff + sizeof(struct eth_hdr) > data_end) {
      return -1;
    }
    memmove(data + len_diff, data, sizeof(struct eth_hdr));
    bpf_xdp_adjust_head(ctx, len_diff);
#else
    bpf_skb_adjust_room(ctx, 0 - len_diff, BPF_ADJ_ROOM_MAC, 0);
#endif

  return 0;
}

static int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {
  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;

  struct eth_hdr *eth = data;
  if (data + sizeof(*eth) > data_end) {
    goto DROP;
  }

  pcn_log(ctx, LOG_TRACE, "in_port: %d, proto: 0x%x, mac_src: %M mac_dst: %M",
          md->in_port, bpf_htons(eth->proto), eth->src, eth->dst);

  struct r_port *in_port = router_port.lookup(&md->in_port);
  if (!in_port) {
    pcn_log(ctx, LOG_ERR, "received packet from non valid port: %d",
            md->in_port);
    goto DROP;
  }

  // Check if the mac destination of the packet is multicast, broadcast, or the
  // unicast address of the router port. If not, drop the packet
  if (eth->dst != in_port->mac && !is_ether_mcast(eth->dst)) {
    pcn_log(ctx, LOG_DEBUG, "mac destination %M MISMATCH %M", eth->dst,
            in_port->mac);
    goto DROP;
  }

  switch (eth->proto) {
    case htons(ETH_P_IP):
      goto IP;  // ipv4 packet
    case htons(ETH_P_ARP):
      goto ARP;  // arp packet
    default:
      goto DROP;
  }

IP:;
  struct iphdr *ip = data + sizeof(*eth);
  if ((void *)ip + sizeof(*ip) > data_end) {
    goto DROP;
  }

  pcn_log(ctx, LOG_TRACE, "ttl: %u", ip->ttl);

  // Find entry in routing table
  struct rt_k k = {32, ip->daddr};
  struct rt_v *rt_entry_p = routing_table.lookup(&k);
  if (!rt_entry_p) {
    pcn_log(ctx, LOG_TRACE, "No routing table match for %I", ip->daddr);
    goto DROP;
  }

  if (rt_entry_p->type != TYPE_LOCALINTERFACE && ip->ttl == 1) {
    return send_icmp_ttl_time_exceeded(ctx, md, in_port->ip);
  }

  __be32 teid;  // Used later by UE and LOCAL branches
  // Used later in FORWARD
  u16 out_port;
  struct r_port *out_port_data = NULL;
  
  // Check the type of destination
  switch (rt_entry_p->type) {
    case TYPE_LOCALINTERFACE:
      goto LOCAL;
    case TYPE_UE:
      goto UE;
    case TYPE_NOLOCALINTERFACE:
      goto FORWARD;
    default:
      pcn_log(ctx, LOG_ERR, "Routing table entry with invalid type");
      goto DROP;
  }

  // Packet directed to a local interface
LOCAL:
  // Check GTP encapsulation
  if (ip->protocol == IPPROTO_UDP) {
    struct udphdr *udp = (void *)ip + 4*ip->ihl;
    if ((void *)udp + sizeof(*udp) > data_end) {
      goto DROP;
    }
 
    if (ntohs(udp->dest) == GTP_PORT) {  // TODO: could write GTP_PORT directly in BE
      // Accept only GTP packets from UE ports
      if (in_port->direction != PORT_DIRECTION_UE) {
        pcn_log(ctx, LOG_WARN,
                "Received GTP encapsulated packet on non-UE port '%d'",
                md->in_port);
        goto DROP;
      }

      if (gtp_decap(ctx, udp, &teid)) {
        pcn_log(ctx, LOG_ERR, "Error decapsulating packet");
        goto DROP;
      }

      goto RATE_LIMIT;
    }
  }

  // Not a GTP packet, send to CP
#ifdef SHADOW
  return pcn_pkt_redirect_ns(ctx, md, md->in_port);
#endif
  return send_packet_for_router_to_slowpath(ctx, md, eth, ip);

  // Packet directed to a User Equipment    
UE:;
  // Retrieve UE data
  struct ue_data *ue_data = user_equipments.lookup(&ip->daddr);
  if (!ue_data) {
    pcn_log(ctx, LOG_ERR, "Unknown user equipment %I", ip->daddr);
    goto DROP;
  }
  teid = ue_data->teid;

  // Use ip addr of the out port as src addr of encap packet
  out_port = rt_entry_p->port;
  out_port_data = router_port.lookup(&out_port);
  if (!out_port_data) {
    pcn_log(ctx, LOG_ERR, "Out port '%d' not found", out_port);
    goto DROP;
  }

  // Encap packet
  if (gtp_encap(ctx, out_port_data->ip, ue_data->tunnel_endpoint, teid)) {
    pcn_log(ctx, LOG_ERR, "Error encapsulating packet");
    goto DROP;
  }

RATE_LIMIT:
  // Packet buffer changed (encap or decap), all pointers need to be recomputed
  data = (void *)(long)ctx->data;
  data_end = (void *)(long)ctx->data_end;

  eth = data;
  if (data + sizeof(*eth) > data_end) {
    goto DROP;
  }

  ip = data + sizeof(*eth);
  if ((void *)ip + sizeof(*ip) > data_end) {
    goto DROP;
  }

  // Limit the rate
  struct packets_rate_data *rate_data = packets_rates.lookup(&teid);
  if (!rate_data) {
    pcn_log(ctx, LOG_WARN, "Packet with unknown TEID '%d'", teid);
    goto DROP;
  }

  if (rate_data->limit > 0) {  // Rate limit == 0 means no limit
    if (rate_data->packets_count >= rate_data->limit) {
      pcn_log(ctx, LOG_TRACE, "Rate limit reached for TEID '%d'", teid);
      goto DROP;
    } else {
      __sync_fetch_and_add(&(rate_data->packets_count), 1);
    }
  }

  // Perform a lookup for the new packet
  k.network = ip->daddr;
  rt_entry_p = routing_table.lookup(&k);
  if (!rt_entry_p) {
    pcn_log(ctx, LOG_TRACE, "No routing table match for %I", ip->daddr);
    goto DROP;
  }

  // TODO: What if UE sends packet to GW?

FORWARD:;
  // Select out interface
  out_port = rt_entry_p->port;
  
  // Retrieve out port data if not already done in UE branch
  if (!out_port_data) {
    out_port_data = router_port.lookup(&out_port);
    if (!out_port_data) {
      pcn_log(ctx, LOG_ERR, "out port '%d' not found", out_port);
      goto DROP;
    }
  }

  // redirect packet to out interface
  return send_packet_to_output_interface(ctx, md, eth, ip, rt_entry_p->nexthop,
                                         out_port, out_port_data->ip,
                                         out_port_data->mac);

  // ARP packet
ARP:;
  struct arp_hdr *arp = data + sizeof(*eth);
  if (data + sizeof(*eth) + sizeof(*arp) > data_end)
    goto DROP;
  if (arp->ar_op == bpf_htons(ARPOP_REQUEST)) { // arp request?
#ifdef SHADOW
    return pcn_pkt_redirect_ns(ctx, md, md->in_port);
#endif
    return send_arp_reply(ctx, md, eth, arp, in_port);
  } else if (arp->ar_op == bpf_htons(ARPOP_REPLY))  // arp reply
    return notify_arp_reply_to_slowpath(ctx, md, arp);
  return RX_DROP;

DROP:
  pcn_log(ctx, LOG_TRACE, "in: %d out: -- DROP", md->in_port);
  return RX_DROP;
}
